{"meta":"<h2 id=\"development-guide\">Development Guide<a href=\"#development-guide\" class=\"anchor\">#</a></h2><h3 id=\"when-to-use\">When to use<a href=\"#when-to-use\" class=\"anchor\">#</a></h3><p>Fields can be used to manage data when it comes to form data manipulation and validation. After being associated with a component, the form data can be automatically written back, read, and verified.</p>\n<h3 id=\"use-caution\">Use caution<a href=\"#use-caution\" class=\"anchor\">#</a></h3><ul>\n<li>With Field <code>init</code> components, <code>value</code> <code>onChange</code> must be placed in init&apos;s third argument, otherwise it may be overridden by init.</li>\n<li><code>Form</code> has been deeply optimized with <code>Field</code> for <code>data acquisition</code> and <code>automatic verification prompt</code>. It is recommended to use <code>Field</code> in <code>Form</code>. Please check Form demo.</li>\n<li>initValue The defaultValue of a similar component, which only takes effect when the component first renders (the ajax asynchronous invocation setting initValue may have missed the first render)</li>\n<li>with <code>parseName=true</code> you could use <code>getValues</code> to get a struct value, but not work in <code>getValue</code> you still need pass complete key</li>\n</ul>\n<h3 id=\"basic-use\">basic use<a href=\"#basic-use\" class=\"anchor\">#</a></h3><pre>Class Demo extends React.Component {\n    Field = new Field(this); // instance creation\n\n    onClick = ()=&gt;{\n        Console.log(this.field.getValue(&apos;name&apos;));\n    }\n    Render() {\n        Const init = this.field.init;\n\n        // Note: initValue will only be assigned when the component is first initialized. If you are using an asynchronous assignment, use setValue\n        Return &lt;div&gt;\n            &lt;Input {...init(&apos;name&apos;,{initValue:&apos;first value&apos;})} /&gt;\n            &lt;button onClick={this.onClick&gt;Get Data&lt;/button&gt;\n        &lt;/div&gt;\n    }\n}</pre><h3 id=\"update-data\">update data<a href=\"#update-data\" class=\"anchor\">#</a></h3><h4 id=\"event-updates\">Event Updates<a href=\"#event-updates\" class=\"anchor\">#</a></h4><pre>Class Demo extends React.Component {\n    Field = new Field(this);\n\n    onClick = ()=&gt;{\n        this.field.setValue(&apos;name&apos;, &apos;newvalue&apos;); // Assignment will automatically trigger render\n    }\n    Render() {\n        Const init = this.field.init;\n\n        Return &lt;div&gt;\n            &lt;Input {...init(&apos;name&apos;)} /&gt;\n            &lt;button onClick={this.onClick}&gt;Settings&lt;/button&gt;\n        &lt;/div&gt;\n    }\n}</pre><h4 id=\"props-update\">props update<a href=\"#props-update\" class=\"anchor\">#</a></h4><pre>Class Demo extends React.Component {\n    Field = new Field(this);\n\n    // Set the data before the component is mounted (this can be replaced with initValue)\n    componentWillMount() {\n        this.field.setValue(&apos;name&apos;, &apos;init Name&apos;)\n    }\n    // Receive data from props\n    componentWillReceiveProps(nextProps) {\n        this.field.setValue(&apos;name&apos;, nextProps.name)\n    }\n    Render() {\n        Const init = this.field.init;\n\n        Return &lt;div&gt;\n            &lt;Input {...init(&apos;name&apos;)} /&gt;\n        &lt;/div&gt;\n    }\n}</pre><h4 id=\"ajax-update\">ajax update<a href=\"#ajax-update\" class=\"anchor\">#</a></h4><pre>Class Demo extends React.Component {\n    Field = new Field(this);\n\n    onClick = ()=&gt;{\n        Ajax({\n            Url:&apos;/demo.json&apos;,\n            Success:(json)=&gt;{\n                // Update of assignment in callback event\n                this.field.setValue(&apos;name&apos;,json.name);\n            }\n        });\n    }\n    Render() {\n        Const init = this.field.init;\n\n        Return &lt;div&gt;\n            &lt;Input {...init(&apos;name&apos;)} /&gt;\n            &lt;button onClick={this.onClick}&gt;Settings&lt;/button&gt;\n        &lt;/div&gt;\n    }\n}</pre><h4 id=\"onchange-update-monitoring\">onChange update monitoring<a href=\"#onchange-update-monitoring\" class=\"anchor\">#</a></h4><p>Two usages:</p>\n<ol>\n<li>Unified management</li>\n</ol>\n<pre>Class Demo extends React.Component {\n    Field = new Field(this,{\n        onChange:(name, value) =&gt; {\n          Switch(name) {\n            Case &apos;name1&apos;:\n              this.field.setValue(&apos;name2&apos;,&apos;value set by name1&apos;);\n              Break;\n            Case &apos;name2&apos;:\n              this.field.setValue(&apos;name1&apos;,&apos;value set by name2&apos;);\n              Break;\n          }\n        }\n    });\n    Render() {\n        Const init = this.field.init;\n\n        Return &lt;div&gt;\n          &lt;Input {...init(&apos;name1&apos;)} /&gt;\n          &lt;Input {...init(&apos;name2&apos;)} /&gt;\n        &lt;/div&gt;\n    }\n}</pre><ol start=\"2\">\n<li>Individual management</li>\n</ol>\n<pre>Class Demo extends React.Component {\n    Render() {\n        Const init = this.field.init;\n\n        Return &lt;div&gt;\n          &lt;Input {...init(&apos;name1&apos;,{\n              Props:{\n                onChange:(v)=&gt;{\n                  this.field.setValue(&apos;name2&apos;,&apos;value set by name1&apos;);\n                }\n              }\n            })} /&gt;\n          &lt;Input {...init(&apos;name2&apos;,{\n              Props:{\n                onChange:(v)=&gt;{\n                  this.field.setValue(&apos;name1&apos;,&apos;value set by name2&apos;);\n                }\n              }\n            })} /&gt;\n        &lt;/div&gt;\n    }\n}</pre><p>For details, please check Demo Demo <code>Associate Control</code></p>\n<h2 id=\"api\">API<a href=\"#api\" class=\"anchor\">#</a></h2>","api":"<h3 id=\"initialization\">initialization<a href=\"#initialization\" class=\"anchor\">#</a></h3><pre>Let myfield = new Field(this [,options]);\n\nor with hooks\n\nlet myfield = Field.useField([options]); // react version must &gt; 16.8</pre><table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Description</th>\n<th>Type</th>\n<th>Optional</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>this</td>\n<td>The incoming call to this class</td>\n<td>React.Component</td>\n<td>must be set</td>\n</tr>\n<tr>\n<td>options</td>\n<td>Some event configuration, detailed parameters are as follows</td>\n<td>Object</td>\n<td>Not required</td>\n</tr>\n</tbody>\n</table>\n<p><code>options</code> configuration item</p>\n<table>\n<thead>\n<tr>\n<th>Parameters</th>\n<th>Description</th>\n<th>Type</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onChange</td>\n<td>all component changes will arrive here [setValue won&apos;t trigger the function]</td>\n<td>Function(name,value)</td>\n<td></td>\n</tr>\n<tr>\n<td>parseName</td>\n<td>Whether to translate <code>name</code> in <code>init(name)</code> (getValues &#x200B;&#x200B;will convert a string with <code>.</code> to an object)</td>\n<td>Boolean</td>\n<td>false</td>\n</tr>\n<tr>\n<td>forceUpdate</td>\n<td>Only the components of PureComponent are recommended to open this forced refresh function, which will cause performance problems (500 components as an example: the render will cost 700ms when it is turned on, and 400ms if it is turned off)</td>\n<td>Boolean</td>\n<td>false</td>\n</tr>\n<tr>\n<td>scrollToFirstError</td>\n<td>scrolling field.validate scrolls to the first errored component, offsets if it is an integer</td>\n<td>Boolean/Number</td>\n<td>true</td>\n</tr>\n<tr>\n<td>autoUnmount</td>\n<td>Automatically delete the Unmout element, if you want to keep the data can be set to false</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>autoValidate</td>\n<td>Automatically validate while value changed</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>values</td>\n<td>initial value</td>\n<td>Object</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"api-interface\">API Interface<a href=\"#api-interface\" class=\"anchor\">#</a></h4><p>The api interface provided by the object after <code>new</code> (eg <code>myfield.getValues()</code>) (The api function starting with <code>set</code> should not be manipulated in render, which may trigger an infinite loop)</p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Description</th>\n<th>Type</th>\n<th>Optional</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>init</td>\n<td>Initialize each component, [Detailed Parameters below] (#init))</td>\n<td>Function(name:String, option:Object)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>getValues &#x200B;&#x200B;</td>\n<td>Get the value of a group of input controls. If no parameters are passed, get the values &#x200B;&#x200B;of all components</td>\n<td>Function([names: String[]])</td>\n</tr>\n<tr>\n<td>getValue</td>\n<td>get the value of a single input control</td>\n<td>Function(name: String)</td>\n</tr>\n<tr>\n<td>setValues &#x200B;&#x200B;</td>\n<td>Sets the value of a set of input controls (triggers render, follow the use of react time)</td>\n<td>Function(obj: Object)</td>\n</tr>\n<tr>\n<td>setValue</td>\n<td>Sets the value of a single input control (triggers render, follow the use of react time)</td>\n<td>Function(name: String, value)</td>\n</tr>\n<tr>\n<td>Validate</td>\n<td>Validate and retrieve the values &#x200B;&#x200B;of a set of input fields and Error</td>\n<td>Function([names: String[]], callback: Function(errors, values))</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>getError</td>\n<td>Get Error of a Single Input Control</td>\n<td>Function(name: String)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>getErrors</td>\n<td>Get Errors of a Group of Input Controls</td>\n<td>Function([name: String])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>setError</td>\n<td>Set Error for a Single Input Control</td>\n<td>Function(name: String, errors:String/Array[String])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>setErrors</td>\n<td>Set Errors of a Group of Input Controls</td>\n<td>Function(obj: Object)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reset</td>\n<td>reset the value of a group of input controls, clear the checksum</td>\n<td>Function([names: String[]])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>resetToDefault</td>\n<td>Resets the value of a group of input controls to the default</td>\n<td>Function([names: String[]])</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>getState</td>\n<td>Judge check status</td>\n<td>Function(name: String)</td>\n<td>&apos;error&apos; &apos;success&apos; &apos;loading&apos; &apos;&apos;</td>\n<td>&apos;&apos;</td>\n</tr>\n<tr>\n<td>getNames</td>\n<td>Get the key of all components</td>\n<td>Function()</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>remove</td>\n<td>Delete the data of a certain control or a group of controls. After deletion, the validate/value associated with it will be cleared.</td>\n<td>Function(name: String/String[])</td>\n</tr>\n<tr>\n<td>addArrayValue</td>\n<td>add data of name like name.{index}</td>\n<td>Function(key: String, index: Number, value1, value2, ...)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>deleteArrayValue</td>\n<td>delete data of name like name.{index}</td>\n<td>Function(key: String, index: Number, howmany)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"init\">init<a href=\"#init\" class=\"anchor\">#</a></h4><pre>init(name, options, props)</pre><table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Description</th>\n<th>Type</th>\n<th>Optional</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>Required unique input control symbol</td>\n<td>String</td>\n</tr>\n<tr>\n<td>options.valueName</td>\n<td>attribute name of the component value, such as Checkbox is <code>checked</code>, Input is <code>value</code></td>\n<td>String</td>\n<td></td>\n<td>&apos;value&apos;</td>\n</tr>\n<tr>\n<td>options.initValue</td>\n<td>The initial value of the component (the component will be read only when rendering for the first time, and later modifying this value is invalid), similar to defaultValue</td>\n<td>any</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>options.trigger</td>\n<td>Name of the event that triggered the data change</td>\n<td>String</td>\n<td></td>\n<td>&apos;onChange&apos;</td>\n</tr>\n<tr>\n<td>options.rules</td>\n<td>Checksum Rules</td>\n<td>Array/Object</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>options.getValueFormatter</td>\n<td>custom way to get value from <code>onChange</code> event, Detailed usage see demo <code>custom data get</code></td>\n<td>Function(value, ...args) parameter order and components are exactly the same The</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>options.getValueFormatter</td>\n<td>custom way to set value. Detailed usage see demo <code>custom data get</code></td>\n<td>Function(values)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>props</td>\n<td>Component-defined events can be written here</td>\n<td>Object</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>autoValidate</td>\n<td>Automatically validate while value changed</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>return</p>\n<pre>{id,value,onChange}</pre><h4 id=\"rules\">rules<a href=\"#rules\" class=\"anchor\">#</a></h4><pre>{\n    rules:[{ required: true }]\n}</pre><p>multiple rule</p>\n<pre>{\n    rules:[{required:true,trigger:&apos;onBlur&apos;},{pattern:/abcd/,message:&apos;match abcd&apos;},{validator:(rule, value, callback)=&gt;{callback(&apos;got error&apos;)}}]\n}</pre><table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Description</th>\n<th>Type</th>\n<th>Optional</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>required</td>\n<td>cannot be empty</td>\n<td>Boolean</td>\n<td>true</td>\n<td><code>undefined/null/&quot;/[]</code> will trigger this rule)</td>\n</tr>\n<tr>\n<td>pattern</td>\n<td>check regular expression</td>\n<td>regular</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>minLength</td>\n<td>Minimum string length / Minimum number of arrays</td>\n<td>Number</td>\n<td></td>\n<td>String/Number/Array</td>\n</tr>\n<tr>\n<td>maxLength</td>\n<td>Maximum length of string / Maximum number of arrays</td>\n<td>Number</td>\n<td></td>\n<td>String/Number/Array</td>\n</tr>\n<tr>\n<td>length</td>\n<td>string exact length / exact number of arrays</td>\n<td></td>\n<td>number</td>\n<td></td>\n<td>String/Number/Array</td>\n</tr>\n<tr>\n<td>min</td>\n<td>Min</td>\n<td>Number</td>\n<td></td>\n<td>String/Number</td>\n</tr>\n<tr>\n<td>max</td>\n<td>maximum</td>\n<td>Number</td>\n<td></td>\n<td>String/Number</td>\n</tr>\n<tr>\n<td>format</td>\n<td>sum of common patterns</td>\n<td>String</td>\n<td>url, email, tel, number</td>\n<td>String</td>\n</tr>\n<tr>\n<td>validator</td>\n<td>Custom validation, (don&apos;t forget to execute <code>callback()</code> when validation is successful, otherwise validation will not return)</td>\n<td>Function(rule,value,callback)</td>\n</tr>\n<tr>\n<td>trigger</td>\n<td>Name of the event that triggered the check</td>\n<td>String/Array</td>\n<td>onChange/onBlur/...</td>\n<td>onChange</td>\n</tr>\n<tr>\n<td>message</td>\n<td>error message</td>\n<td>String</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"custom-component-access-to-field-standards\">Custom Component Access to Field Standards<a href=\"#custom-component-access-to-field-standards\" class=\"anchor\">#</a></h2><ul>\n<li><p>Supports controlled mode (value+onChange) <code>Must</code></p>\n<ul>\n<li>value control component data display</li>\n<li>onChange callback function when the component changes (the first parameter can be given to value)</li>\n</ul>\n</li>\n<li><p>One complete operation throws an onChange event\n For example, there is a process that indicates the status of the progress, it is recommended to increase the API <code>onProcess</code>; if there is a Start indicates the startup state, it is recommended to increase the API <code>onStart</code></p>\n</li>\n<li><p>Clear data when <code>value={undefined}</code>, field&apos;s reset function will send undefined data to all components</p>\n</li>\n</ul>\n<pre>componentWillReceiveProps(nextProps) {\n    if (&apos;value&apos; in nextProps ) {\n        this.setState({\n           value: nextProps.value === undefined? []: nextProps.value   //  set value after clear\n        })\n    }\n}</pre><h2 id=\"known-issues\">Known Issues<a href=\"#known-issues\" class=\"anchor\">#</a></h2><ul>\n<li>Why doesn&apos;t the callback function enter the <code>this.field.validate</code> manually? A: Is it safe to define the validator method to ensure that the <code>callback</code> can be executed on any branch?</li>\n</ul>\n"}